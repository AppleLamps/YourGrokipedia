/**
 * Markdown Module - Handles markdown rendering
 */

// Import dependencies
import { escapeHtml } from './utils.js';

/**
 * Render markdown text to HTML
 * @param {string} md - Markdown text
 * @returns {string} HTML string
 */
export function renderMarkdown(md) {
    if (!md) return '';

    // Pre-process: extract HTML tables first (LLM may return HTML directly)
    const tableBlocks = [];
    md = extractHtmlTables(md, tableBlocks);

    // Then extract and render markdown pipe tables
    md = renderTables(md, tableBlocks);

    const lines = md.split(/\r?\n/);
    let html = '';
    let inList = false;
    let inComparisonPair = false;
    let inBlockquote = false;

    const flushList = () => { if (inList) { html += '</ul>'; inList = false; } };
    const flushComparisonPair = () => { if (inComparisonPair) { html += '</div>'; inComparisonPair = false; } };
    const flushBlockquote = () => { if (inBlockquote) { html += '</blockquote>'; inBlockquote = false; } };

    const formatInline = (t) => {
        // Unescape common markdown escapes from scraped content
        t = t.replace(/\\+([\[\]()]|\\)/g, '$1');

        // Extract and hide raw URLs (but keep markdown links)
        const linkTokens = [];

        // First, handle markdown links [text](url)
        t = t.replace(/\[([^\]]+)\]\((https?:\/\/[^\s)]+)\)/g, (_, text, url) => {
            const token = `___LINK_${linkTokens.length}___`;
            linkTokens.push({ text, url, type: 'markdown' });
            return token;
        });

        // Hide standalone raw URLs in parentheses like (https://...)
        t = t.replace(/\((https?:\/\/[^\s)]+)\)/g, (_, url) => {
            const token = `___LINK_${linkTokens.length}___`;
            linkTokens.push({ text: null, url, type: 'hidden' });
            return token;
        });

        // Hide standalone raw URLs
        t = t.replace(/(^|[\s])((https?:\/\/)[^\s<]+)/g, (_, prefix, url) => {
            const token = `___LINK_${linkTokens.length}___`;
            linkTokens.push({ text: null, url, type: 'hidden' });
            return prefix + token;
        });

        // Replace W: and G: patterns with placeholder tokens BEFORE escaping
        t = t.replace(/\bW:\s*/g, '___BADGE_W___');
        t = t.replace(/\bG:\s*/g, '___BADGE_G___');
        t = t.replace(/\(W\)/g, '___BADGE_W___');
        t = t.replace(/\(G\)/g, '___BADGE_G___');
        t = t.replace(/Before\s*\(W\):\s*/gi, '___BADGE_W___ ');
        t = t.replace(/After\s*\(G\):\s*/gi, '___BADGE_G___ ');

        // Replace markdown formatting with placeholders
        t = t.replace(/"([^"]+)"/g, '___QUOTE_START___$1___QUOTE_END___');
        t = t.replace(/\*\*(.+?)\*\*/g, '___BOLD_START___$1___BOLD_END___');
        t = t.replace(/\*(.+?)\*/g, '___ITALIC_START___$1___ITALIC_END___');

        // NOW escape HTML to prevent XSS
        t = escapeHtml(t);

        // Replace placeholders with actual HTML
        t = t.replace(/___BADGE_W___/g, '<span class="source-badge badge-wikipedia">W</span>');
        t = t.replace(/___BADGE_G___/g, '<span class="source-badge badge-grokipedia">G</span>');
        t = t.replace(/___QUOTE_START___/g, '<span class="quote-text">"');
        t = t.replace(/___QUOTE_END___/g, '"</span>');
        t = t.replace(/___BOLD_START___/g, '<strong>');
        t = t.replace(/___BOLD_END___/g, '</strong>');
        t = t.replace(/___ITALIC_START___/g, '<em>');
        t = t.replace(/___ITALIC_END___/g, '</em>');

        // Replace link tokens
        linkTokens.forEach((link, index) => {
            if (link.type === 'hidden') {
                // Hidden URLs are removed entirely (no paperclip icon)
                t = t.replace(`___LINK_${index}___`, '');
            } else {
                const safeText = escapeHtml(link.text);
                const safeUrl = escapeHtml(link.url);
                t = t.replace(
                    `___LINK_${index}___`,
                    `<a href="${safeUrl}" target="_blank" rel="noopener noreferrer">${safeText}</a>`
                );
            }
        });

        // Convert numeric citations to superscript
        t = t.replace(/\[(\d{1,3})\]/g, '<sup class="citation">[$1]</sup>');

        return t;
    };

    for (const raw of lines) {
        const line = raw.trim();

        // Inject pre-rendered table HTML blocks (generated by renderTables)
        const tableToken = line.match(/^___TABLEBLOCK_(\d+)___$/);
        if (tableToken) {
            flushList();
            flushComparisonPair();
            flushBlockquote();
            const index = parseInt(tableToken[1], 10);
            html += tableBlocks[index] || '';
            continue;
        }

        // Skip empty lines
        if (!line) {
            flushList();
            flushBlockquote();
            continue;
        }

        // Skip reference definitions like [1]: https://...
        if (line.match(/^\[\d+\]:\s*\S+/)) {
            flushList();
            flushComparisonPair();
            flushBlockquote();
            continue;
        }

        // Skip lines that are just URLs
        if (line.match(/^https?:\/\/\S+$/)) {
            continue;
        }

        // Horizontal rules
        if (line.match(/^---+$/) || line.match(/^\*\*\*+$/) || line.match(/^___+$/)) {
            flushList();
            flushComparisonPair();
            flushBlockquote();
            html += '<hr>';
            continue;
        }

        // Blockquotes
        if (line.startsWith('>')) {
            flushList();
            flushComparisonPair();
            if (!inBlockquote) {
                html += '<blockquote>';
                inBlockquote = true;
            }
            html += `<p>${formatInline(line.replace(/^>\s*/, ''))}</p>`;
            continue;
        } else {
            flushBlockquote();
        }

        // Check for Before/After pattern
        const beforeAfterMatch = line.match(/Before\s*\(W\):\s*(.+?)\s*-\s*After\s*\(G\):\s*(.+?)(?:\s*-\s*Change:\s*(.+))?$/i);

        // Check for headers (h1-h6)
        const h6 = line.match(/^######\s+(.+)/);
        const h5 = !h6 && line.match(/^#####\s+(.+)/);
        const h4 = !h5 && line.match(/^####\s+(.+)/);
        const h3 = !h4 && line.match(/^###\s+(.+)/);
        const h2 = !h3 && line.match(/^##\s+(.+)/);
        const h1 = !h2 && line.match(/^#\s+(.+)/);
        const ol = line.match(/^\d+\.\s+(.+)/);
        const ul = !ol && line.match(/^[-â€¢*]\s+(.+)/);

        if (h6) {
            flushList();
            flushComparisonPair();
            html += `<h4>${formatInline(h6[1])}</h4>`;
            continue;
        }
        if (h5) {
            flushList();
            flushComparisonPair();
            html += `<h4>${formatInline(h5[1])}</h4>`;
            continue;
        }
        if (h4) {
            flushList();
            flushComparisonPair();
            html += `<h3>${formatInline(h4[1])}</h3>`;
            continue;
        }
        if (h3) {
            flushList();
            flushComparisonPair();
            html += `<h3>${formatInline(h3[1])}</h3>`;
            continue;
        }
        if (h2) {
            flushList();
            flushComparisonPair();
            html += `<h2>${formatInline(h2[1])}</h2>`;
            continue;
        }
        if (h1) {
            flushList();
            flushComparisonPair();
            html += `<h1>${formatInline(h1[1])}</h1>`;
            continue;
        }

        // Handle Before/After comparison pairs
        if (beforeAfterMatch) {
            flushList();
            if (!inComparisonPair) {
                html += '<div class="comparison-pair">';
                inComparisonPair = true;
            }
            const beforeText = formatInline(beforeAfterMatch[1]);
            const afterText = formatInline(beforeAfterMatch[2]);
            const changeNote = beforeAfterMatch[3] ? formatInline(beforeAfterMatch[3]) : '';

            html += `<div class="before-after"><strong>Before:</strong> ${beforeText}</div>`;
            html += `<div class="before-after"><strong>After:</strong> ${afterText}</div>`;
            if (changeNote) {
                html += `<div class="change-note">Change: ${changeNote}</div>`;
            }
            flushComparisonPair();
            continue;
        }

        // Check if line contains "Change:" which might be part of a comparison
        if (line.match(/^Change:\s*/i) && inComparisonPair) {
            html += `<div class="change-note">${formatInline(line)}</div>`;
            flushComparisonPair();
            continue;
        }

        if (ol || ul) {
            flushComparisonPair();
            if (!inList) { html += '<ul>'; inList = true; }
            const item = formatInline((ol ? ol[1] : ul[1]));
            html += `<li>${item}</li>`;
            continue;
        }

        flushList();
        flushComparisonPair();
        html += `<p>${formatInline(line)}</p>`;
    }
    flushList();
    flushComparisonPair();
    flushBlockquote();
    return html;
}

/**
 * Extract HTML tables from content and replace with tokens
 * Handles cases where LLM returns HTML tables directly instead of markdown
 * @param {string} md - Content that may contain HTML tables
 * @param {Array} tableBlocks - Array to store extracted table HTML
 * @returns {string} Content with HTML tables replaced by tokens
 */
function extractHtmlTables(md, tableBlocks = []) {
    if (!md) return '';

    // Match HTML tables with optional wrapper div
    // Handles: <table>...</table> and <div class="table-wrapper"><table>...</table></div>
    const tablePattern = /(<div[^>]*class="[^"]*table-wrapper[^"]*"[^>]*>[\s\S]*?<\/div>|<table[\s\S]*?<\/table>)/gi;

    return md.replace(tablePattern, (match) => {
        // Sanitize the HTML table - only allow safe table-related tags and attributes
        const sanitized = sanitizeTableHtml(match);
        const token = `___TABLEBLOCK_${tableBlocks.length}___`;
        tableBlocks.push(sanitized);
        return token;
    });
}

/**
 * Sanitize HTML table to prevent XSS while preserving table structure
 * @param {string} html - HTML table string
 * @returns {string} Sanitized HTML
 */
function sanitizeTableHtml(html) {
    // Define allowed tags and their allowed attributes
    const allowedTags = {
        'table': ['class'],
        'thead': [],
        'tbody': [],
        'tr': [],
        'th': ['class', 'colspan', 'rowspan'],
        'td': ['class', 'colspan', 'rowspan'],
        'div': ['class'],
        'span': ['class'],
        'strong': [],
        'em': [],
        'b': [],
        'i': [],
        'sup': ['class', 'title'],
        'a': ['href', 'target', 'rel', 'class']
    };

    // Create a temporary div to parse the HTML
    const temp = document.createElement('div');
    temp.innerHTML = html;

    // Recursively sanitize the element
    function sanitizeElement(el) {
        const children = Array.from(el.childNodes);
        for (const child of children) {
            if (child.nodeType === Node.ELEMENT_NODE) {
                const tagName = child.tagName.toLowerCase();
                if (!allowedTags[tagName]) {
                    // Replace disallowed element with its text content
                    const text = document.createTextNode(child.textContent || '');
                    el.replaceChild(text, child);
                } else {
                    // Remove disallowed attributes
                    const allowedAttrs = allowedTags[tagName];
                    const attrs = Array.from(child.attributes);
                    for (const attr of attrs) {
                        if (!allowedAttrs.includes(attr.name)) {
                            child.removeAttribute(attr.name);
                        }
                        // Extra safety: sanitize href attributes
                        if (attr.name === 'href' && !attr.value.match(/^https?:\/\//i)) {
                            child.removeAttribute('href');
                        }
                    }
                    // Recursively sanitize children
                    sanitizeElement(child);
                }
            }
        }
    }

    sanitizeElement(temp);

    // Add standard table classes if missing
    const tables = temp.querySelectorAll('table');
    tables.forEach(table => {
        if (!table.classList.contains('md-table')) {
            table.classList.add('md-table');
        }
    });

    // Wrap tables without wrapper div
    let result = temp.innerHTML;
    if (!result.includes('table-wrapper') && result.includes('<table')) {
        result = `<div class="table-wrapper">${result}</div>`;
    }

    return result;
}

/**
 * Render markdown tables to HTML
 * @param {string} md - Markdown text
 * @param {Array} tableBlocks - Array to store rendered table HTML blocks
 * @returns {string} Markdown with tables converted to HTML tokens
 */
function renderTables(md, tableBlocks = []) {
    const lines = md.split(/\r?\n/);
    let result = [];
    let tableLines = [];
    let inTable = false;

    for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const trimmed = line.trim();

        // Check if this is a table row (starts and ends with |, or has | separators)
        const isTableRow = trimmed.startsWith('|') && trimmed.endsWith('|');
        const isSeparatorRow = /^\|?[\s\-:|]+\|?$/.test(trimmed) && trimmed.includes('-');

        if (isTableRow || (inTable && isSeparatorRow)) {
            if (!inTable) {
                inTable = true;
            }
            tableLines.push(trimmed);
        } else {
            if (inTable && tableLines.length > 0) {
                // End of table, render it
                const tableHtml = renderTableHTML(tableLines);
                const token = `___TABLEBLOCK_${tableBlocks.length}___`;
                tableBlocks.push(tableHtml);
                result.push(token);
                tableLines = [];
                inTable = false;
            }
            result.push(line);
        }
    }

    // Handle table at end of document
    if (inTable && tableLines.length > 0) {
        const tableHtml = renderTableHTML(tableLines);
        const token = `___TABLEBLOCK_${tableBlocks.length}___`;
        tableBlocks.push(tableHtml);
        result.push(token);
    }

    return result.join('\n');
}

/**
 * Convert table lines to HTML table
 * @param {string[]} lines - Array of table row strings
 * @returns {string} HTML table
 */
function renderTableHTML(lines) {
    if (lines.length < 2) return lines.join('\n');

    // Parse header row
    const headerCells = parseTableRow(lines[0]);

    // Check if second line is separator
    let dataStartIndex = 1;
    if (lines[1] && /^[\s\-:|]+$/.test(lines[1].replace(/\|/g, ''))) {
        dataStartIndex = 2;
    }

    let html = '<div class="table-wrapper"><table class="md-table">';

    // Render header
    html += '<thead><tr>';
    for (const cell of headerCells) {
        html += `<th>${formatTableCell(cell.trim())}</th>`;
    }
    html += '</tr></thead>';

    // Render body
    html += '<tbody>';
    for (let i = dataStartIndex; i < lines.length; i++) {
        const cells = parseTableRow(lines[i]);
        if (cells.length === 0) continue;

        html += '<tr>';
        for (let j = 0; j < headerCells.length; j++) {
            const cellContent = cells[j] || '';
            html += `<td>${formatTableCell(cellContent.trim())}</td>`;
        }
        html += '</tr>';
    }
    html += '</tbody></table></div>';

    return html;
}

/**
 * Format inline content in table cells (simplified version of formatInline)
 * @param {string} t - Cell text
 * @returns {string} Formatted HTML
 */
function formatTableCell(t) {
    if (!t) return '';

    // Unescape
    t = t.replace(/\\+([\[\]()]|\\)/g, '$1');

    // Remove raw URLs entirely (no paperclip icon)
    t = t.replace(/\((https?:\/\/[^\s)]+)\)/g, '');
    t = t.replace(/(^|[\s])((https?:\/\/)[^\s<]+)/g, '$1');

    // Replace W: and G: patterns
    t = t.replace(/\bW:\s*/g, '___BADGE_W___');
    t = t.replace(/\bG:\s*/g, '___BADGE_G___');

    // Replace markdown formatting with placeholders
    t = t.replace(/"([^"]+)"/g, '___QUOTE_START___$1___QUOTE_END___');
    t = t.replace(/\*\*(.+?)\*\*/g, '___BOLD_START___$1___BOLD_END___');
    t = t.replace(/\*(.+?)\*/g, '___ITALIC_START___$1___ITALIC_END___');

    // Escape HTML
    t = escapeHtml(t);

    // Replace placeholders with HTML
    t = t.replace(/___BADGE_W___/g, '<span class="source-badge badge-wikipedia">W</span>');
    t = t.replace(/___BADGE_G___/g, '<span class="source-badge badge-grokipedia">G</span>');
    t = t.replace(/___QUOTE_START___/g, '<span class="quote-text">"');
    t = t.replace(/___QUOTE_END___/g, '"</span>');
    t = t.replace(/___BOLD_START___/g, '<strong>');
    t = t.replace(/___BOLD_END___/g, '</strong>');
    t = t.replace(/___ITALIC_START___/g, '<em>');
    t = t.replace(/___ITALIC_END___/g, '</em>');

    // Citations
    t = t.replace(/\[(\d{1,3})\]/g, '<sup class="citation">[$1]</sup>');

    return t;
}

/**
 * Parse a table row into cells
 * @param {string} row - Table row string
 * @returns {string[]} Array of cell contents
 */
function parseTableRow(row) {
    // Remove leading/trailing pipes and split
    let cleaned = row.trim();
    if (cleaned.startsWith('|')) cleaned = cleaned.slice(1);
    if (cleaned.endsWith('|')) cleaned = cleaned.slice(0, -1);
    return cleaned.split('|');
}

